# ================================== Нахождение максимального элемента списка =================================================

def search_max(array: list[int or float], condition: function) -> (int or float, int):
    """
    Нахождение максимального элемента массивва и его индекса, а так же дополнительное условие, которое выполняет
    параметр condition, который имеет тип данных (класс) function, в него подставляется lambda функция ( анонимная функция,
    которая не имеет названия),в которой указывается любое дополнительное условие, например найти больший элемент среди четных или нечетных.

    :param array: Пренимает список целых или дробных чисел
    :param condition: Пренимает lambda функция ( анонимная функция,которая не имеет названия)
    :return: Возвращает максимальный элемент исходя из дополнительного условия condition и его индекс
    """

    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if len(array) == 0 or len(array) == 1: return array

    index_max = 0

    for i in range(1, len(array), 1):
        if array[i] > array[index_max] and condition(array[i]):
            index_max = i

    return (array[index_max], index_max)

print(search_max([1, 2, 3, 4, 5, 6, 7, 8], condition=lambda elem: True if elem % 2 != 0 else False))


# ========================================== Реверс списка ==================================================================================

def revert(array: list[int or float]) -> list[int or float]:
    """
    Производит реверс массива, длинна массива в функции range делится нацело на 2, при этом мы получаем
    количество итераций, в каждой из которых крайние слева элементы меняются местами крайними справа, таким путем список переворачивается
    задом наперед. Запись array[length -1 - i] говорит о том что мы берем элемент равный длинне массива
    и отнимаем 1 чтобы получить индексы элементов, которые будет перебираться, потому что элементы считаются с единицы, а индексы с нуля
    при этом кадый раз мы отнимаем i чтобы сдвиг справа был ровно такой же как и слева, от length тоесть от количества элементов
    мы отнимаем i ( количество уже пройденных элементов) таким образом получаем текущий справа
    :param array: Пренимает массив
    :return: Возвращает перевернутый массив
    """
    length = len(array)

    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if length == 0 or length == 1: return array

    for i in range(0, len(array) // 2, 1):
        array[i], array[length-i-1] = array[length-i-1], array[i]
    return array


def revert_cut(array: list[int or float]) -> list[int or float]:
    """
    Производит реверс массива при помощи среза, тоесть считывает его задом на перед и тут же возвращает
    :param array: Пренимает массив
    :return: Возвращает перевернутый массив
    """
    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if len(array) == 0 or len(array) == 1: return array

    return array[::-1]

# ====================================================== Циклический сдвиг элементов в лево на 1 элемент ====================================================

def shift_elems_in_left(array: list[any]) -> list[any]:
    """
    Выполняет циклический сдвиг элементов влево на 1 элемент
    Есть 2 варианта исполнения : либо так, как написано либо
    убераются one_elem = array[0] и array[length - 1] = one_elem и пишется строка равенства такая array[i], array[i+1] = array[i+1], array[i]
    В данном случае length - 1 говорит о том что мы обращаемся к элементам по индексу, а 0, length - 1, 1 говорит о том что начинаем с нулевого индекса
    array[i] = array[i + 1] каждому текущему элементу приравниваем последующий
    one_elem = array[0] берем нулевой элемент и по выходу из цикла приравниваем последнему первый array[length - 1] = one_elem
    Иначе последние 2 элемента будут одинаковые и будут равны последнему
    :param array: Пренимает массив
    :return: Возвращает массив со сдвигом элементов влево на 1 элемент
    """
    length = len(array)

    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if length == 0 or length == 1: return array

    one_elem = array[0]

    for i in range(0, length - 1, 1):
        array[i] = array[i + 1]

    array[length - 1] = one_elem

    return array

print(shift_elems_in_left([1, 2, 3, 4, 5, 6, 7, 8]))


# ====================================================== Циклический сдвиг элементов в право на 1 элемент ====================================================


def shift_elems_in_right(array: list[any]) -> list[any]:
    """
    Выполняет циклический сдвиг элементов влево на 1 элемент
    Есть 2 варианта исполнения : либо так как написано либо
    убераются one_elem = array[-1] и array[0] = one_elem и пишется строка равенства такая array[i], array[i - 1] = array[i - 1], array[i]
    В данном случае length - 1 говорит о том что мы обращаемся к элементам по индексу, а length - 1, 0, -1 говорит о том что начинаем с последнего индекса, то есть с конца массива
    array[i] = array[i - 1] каждому текущему элементу приравниваем предыдущий
    one_elem = array[-1] берем нулевой элемент и по выходу из цикла приравниваем первому элементу послений array[0] = one_elem
    Иначе первые 2 элемента будут одинаковые и будут равны первому
    :param array: Пренимает массив
    :return: Возвращает массив со сдвигом элементов влево на 1 элемент
    """
    length = len(array)

    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if length == 0 or length == 1: return array

    one_elem = array[-1]

    for i in range(length - 1, 0, -1):
        array[i] = array[i - 1]

    array[0] = one_elem

    return array


# ============================================ Преобразование массива целых чисел в одно число =========================================================

data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

def converts_to_number(data: list[int]) -> int or list:
    """
    Преобразует массив целых чисел в единое число
    int(''.join(map(str, data))) говорит о том что сначала функция map конвертирует каждый элемент списка в строку,
    То есть получим список, где каждая цифра (элемент массива) независимая строка, они разделены запятыми
    Затем при помощи ''.join мы объединяем все строки в одну, убирая при этом запятые и при помощи int() переводим строку в число
    Таким образом на ваходе получаем целое число
    :param data: Пренимает массив целых чисел
    :return: Возвращает число
    """

    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if len(array) == 0 or len(array) == 1: return array

    number = int(''.join(map(str, data)))

    return number

# ================================================= Формирует массив из целого числа =====================================================


def create_arr_nums(data: int) -> list[int]:
    """
    Преобразует целое число в список целых чисел, разбивая число на цифры
    while data != 0 перебираем данные пока их количество не равно нулю
    lst.append(data % 10) добавляем в сптсок каждую одну цыфру с конца
    data //= 10 удаляем последнюю цифру из принятого числа, потому что мы ее уже добавили в список и при следующей итерации цикла последняя цифра должна быть уже другая

    :param data: Пренимает строку целых чисел

    :return: Возвращает список целых чисел, готовый для вывода пользователю
    """

    assert isinstance(data, int), TypeError('Получен не верный тип данных, ожидалось целое число')

    lst = []

    while data != 0:
        lst.append(data % 10)

        data //= 10

    return lst

# ============================================= Палиндром =============================================================


def is_palindrome(arr: list or str) -> bool:
    """
    Проверяет данные на палиндром, при помощи среза производит сравнение принятой строки с такой же, но перевернутой
    :param s: Пренимает строку или число
    :return: True or False
    """
    assert isinstance(arr, str or list), TypeError('Получен не верный тип данных, ожидался итерируемый объект')

    assert len(arr) >= 2, ValueError('Итерируемый объект, имеющий меньше 2 символов не может быть палиндромом')

    return s == s[::-1]


def is_palindromes(arr: list or str) -> bool:

    assert isinstance(arr, str or list), TypeError('Получен не верный тип данных, ожидался итерируемый объект')

    assert len(arr) >= 2, ValueError('Итерируемый объект, имеющий меньше 2 символов не может быть палиндромом')

    for i in range(0, len(arr) // 2, 1):

        if arr[i] != arr[-i-1]:
            return False

    return True

# ========================================= Нахождение среднего арифметического числа в списке ======================================


def average(lst):
    """
    Пренимает массив, выполняет сложение всех элементов и делит полученную сумму на количество элементов массива
    :param lst:
    :return:
    """
    assert isinstance(lst, list), TypeError('Получен не верный тип данных ожидался список')

    assert len(lst) != 0, ValueError('Пустой список невозможно обработать')

    return sum(lst) / len(lst)


# ====================================================== Сортировка пузырьком =================================================================================================


def bubble_sort(array: list[int or float], order_by=lambda x, y: x > y):
    """
    Сортировка пузырьком с использованием lambda функции, которая устанавливает признак сортировки,
    В данном случае перемещение элементов происходит если array[j] > array[j + 1], то есть если текущий элемент больше следующего, так же этот признак может меняться
    Внешний цикл говорит о том сколько раз будет искаться максимальное или минимальное значение и зависит оно от количества индексов в списке
    Внутренний цикл сравнивает текущий элемент со следующим, если текущий больше или меньше (завиит от признака сортировки, то есть сортировка выполняется от большего к меньшему или наоборот)
    то меняет его местами со следующим и так до конца списка
    Во внутреннем цикле len(array) - i - 1 говорит о том что мы каждую итерацию внешнего цикла во внутреннем ограничиваем сортировку на i элементов потому что они уже отсортированы

    :param array: Пренимает массив

    :param order_by: Пренимает lambda функцию, которая устанавливает признак сортировки, если изменить условие в lambda то изменится и признак
    Например сейчас сортируется от меньшего к большему, если изменить знак > на <, то сортироватся будет от большего к меньшему

    :return: Возвращает отсортированный массив
    """
    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if len(array) == 0 or len(array) == 1: return array

    for i in range(0, len(array), 1):

        for j in range(0, len(array) - i - 1, 1):

            if order_by(array[j], array[j + 1]):
                array[j], array[j + 1] = array[j + 1], array[j]

    return array

# ============================================================== Бинарная сортировка ============================================================================================

# центр вычисляется по формуле: правая граница массива минус левая и деленная нацело на 2 + левая граница: centr = (right - left) // 2 + left
# Если ищем новую левую границу то предыдущий centr + 1
# Если ищем новую правую границу то предыдущий centr - 1


def binary_search(array: list[int or float], target):
    """
    МАССИВ ДОЛЖЕН БЫТЬ ОТСОРТИРОВАН!
    Функция позволяет за 8 итераций определить есть искомый элемент в массиве или нет
    Метод заключается в делении массива пополам при каждой итерации, нахождении левой и правой границы а так же центра искомого участка массива
    Цикл останавливается когда левая и правая границы становятся на один и тот же элемент, в этом случае элемент искомый отсутствует и вернется False
    Если элемент найден то он будет равен центру,в этом случае вернется True
    :param array: Пренимает отсортированный массив
    :return: Возвращает True или False
    """
    assert isinstance(array, list), TypeError('Получен не верный тип данных, ожидался массив')

    if len(array) == 0 or len(array) == 1: return array

    left = array[0]
    rigt = len(array) - 1

    while left <= rigt:

        centr = (rigt - left) // 2 + left

        if array[centr] == target:
            return True

        if array[centr] < target:
            left = centr + 1

        else:
            rigt = centr - 1

    return False

# ========================================================= Сортировка выбором ===============================================================

def choise_sort(arr: list, condition=lambda x, y: x < y, key=lambda x: int(x)) -> list:
    """
    Пренимает массив строк, сортирует согласно заданному признаку сортировки
    :param arr: Пренимает массив строк
    :return: Возвращает сортированный массив
    """

    if not isinstance(arr, list): raise TypeError()

    if len(arr) == 0 or len(arr) == 1: return arr

    for i in range(0, len(arr)-1, 1):
        index_min = i

        for j in range(i+1, len(arr), 1):
            if condition(key(arr[index_min]), key(arr[j])):
                index_min = j

        arr[i], arr[index_min] = arr[index_min], arr[i]


    return arr


